# -*- coding: utf-8 -*-
"""collabRecom.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12y01kRjx7Fv7VV1px7FtezSKSwPWXwqf
"""

import pandas as pd
import numpy as np
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.metrics import mean_squared_error
from sklearn.model_selection import train_test_split

# Import necessary libraries
import pandas as pd
import numpy as np
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.model_selection import train_test_split

# Load the dataset
file_path = "/content/Anon_Data.xlsx"  # Replace with your dataset path
data = pd.read_excel(file_path)

# Step 1: Replace RollNumber links with numeric IDs
roll_number_mapping = {roll: idx + 1 for idx, roll in enumerate(data['RollNumber'].unique())}
data['RollNumber'] = data['RollNumber'].map(roll_number_mapping)

# Step 2: Prepare Ratings Matrix
ratings_matrix = data.pivot_table(index='RollNumber', columns='Course Code', values='Marks (200)').fillna(0)

# Step 3: Compute User Similarity
user_similarity = cosine_similarity(ratings_matrix)
user_similarity_df = pd.DataFrame(user_similarity, index=ratings_matrix.index, columns=ratings_matrix.index)

# Step 4: Collaborative Filtering Recommendation Function with Priority Ranks
def collaborative_recommend(student_id, ratings_matrix, user_similarity_df, top_n=5):
    if student_id not in ratings_matrix.index:
        return f"Student ID {student_id} not found in the dataset."

    # Compute similarity and predictions
    similar_students = user_similarity_df[student_id].sort_values(ascending=False)
    weighted_scores = ratings_matrix.loc[similar_students.index].T.dot(similar_students)
    normalization = similar_students.sum()

    # Handle division by zero (no similar students)
    if normalization == 0:
        recommendations = pd.Series(0, index=ratings_matrix.columns)  # Assign 0 if no similarity
    else:
        weighted_scores /= normalization
        recommendations = weighted_scores

    # Replace NaN with 0
    recommendations.fillna(0, inplace=True)

    # Scale predictions to 0-100
    scaled_recommendations = (recommendations / recommendations.max()) * 100
    scaled_recommendations[scaled_recommendations < 1] = 1  # Minimum score threshold

    # Rank the recommendations by priority
    ranked_recommendations = scaled_recommendations.sort_values(ascending=False).head(top_n)
    ranked_recommendations = pd.Series(
        {course: rank + 1 for rank, course in enumerate(ranked_recommendations.index)}
    )

    # Return ranked recommendations
    return ranked_recommendations

# Prompt User Input
try:
    # Convert input to integer and validate
    student_id = int(input("Enter the numeric RollNumber of the student: "))

    # Generate recommendations
    recommendations = collaborative_recommend(student_id, ratings_matrix, user_similarity_df)

    # Display Recommendations
    if isinstance(recommendations, str):  # If no recommendations or invalid student ID
        print(recommendations)
    else:
        print(f"\nTop Recommendations for Student {student_id}:")
        for course, rank in recommendations.items():
            print(f"Course Code: {course}, Priority Rank: {rank}")
except ValueError:
    print("Invalid input. Please enter a valid numeric RollNumber.")